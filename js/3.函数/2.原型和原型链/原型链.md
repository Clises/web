#一、原型

## prototype:原型，每个函数都有prototype属性，默认指向的一个object空对象（即称：原型对象）
```javascript
function Foo() {
    }
    console.log(Foo.prototype)   //constructor构造函数， __proto__
```
![函数原型链](./image/函数原型链.jpg)
这里为什么要说是空对象，明明看到有constructor、__proto__两个属性，其实是这个object对象中没有我们所需要的属性，当然可以去给原型中添加我们需要属性或者方法。

## 给原型对象添加属性(一般都是方法)
````javascript
Foo.prototype.method=function () {
    console.log("method()")
}
console.log(Foo.prototype) 
````
此时在原型中可以看到method属性已经添加到Foo()中去。
![函数原型链](./image/添加属性.png)

现在我们通过创建实例去访问我们刚才添加的方法
```javascript
var fun=new Foo()
fun.method()   // 可以看到返回的是method()
```

![函数原型链](./image/函数的protype属性.png)

由此可以看到构造函数跟原型对象是相互引用的关系。

## 显示原型和隐式原型
每个函数function都有一个prototype，即显示原型(属性);
每一个实例对象都有一个__proto__ 称为隐式原型（属性）
我们继续之前的构造函数：
```javascript
var fun=new Foo() 
//内部语句this.__proto__=Foo.prototype
console.log(fun.__proto__)
//对象的隐式原型的值为其对应构造函数的显示原型的值
console.log(Foo.prototype===fun.__proto__)
fun.method()   // 可以看到返回的是method()
```

可以看到对象的__proto__属性在创建对象时是自动添加的，默认值为构造函数的prototype属性值。

## constructor
在原型对象中有一个属性constructor，当我们自定义构造函数之后，其原型对象只会默认取得constructor值，可以通过该属性判断出实例是由哪个构造函数创建的。

```javascript
    console.log(fun.prototype.constructor===Foo)  //true
```
  那么构造函数的原型对象是由什么来创建的呢？
我们去构造函数中寻找：
```javascript
Foo.prototype.__proto__.constructor // ƒ Object() { [native code] }
```
这样一来可以看到构造函数原型链的其他方法，原来是从Object 上继承来的。
这里的Object本来就存在，这里我们可以去看它的原型链。


#二、原型链

原型链(本质上就隐式原型链，是用来查找对象的。)
![函数原型链](./image/原型链.png)
  在创建函数之前，已经就有了一个Object函数对象，js在加载引擎的时候首先会把这个内置的函数加载进来，然后在去执行我们的一些方法，访问一个对象的属性时，先从自身属性中查找，找到返回，如果没有，再沿着__proto__这条链上查找，找到返回，如果最终没找到，返回undefined，而原型链的尽头就在Object对象之中即为__proto__=null;




